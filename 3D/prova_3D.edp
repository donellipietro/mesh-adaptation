load "iovtk"
load "msh3"
load "mmg"
load "mshmet"
load "medit"
load "lapack"

// Create unit cube mesh
int n = 20;
mesh Th2 = square(n, n, [x, y]);
mesh3 Th = buildlayers(Th2, n, zbound = [0, 1]);


func bool POWER(real[int, int] &M, real exp) {
    
    // EVD
    complex [int] cev(3);
    complex [int, int] ceV(3, 3);
    dgeev(M, cev, ceV);

    // real part
    real [int] ev(3);
    real [int, int] eV(3, 3);
    for(int i = 0; i<3; i++) {
        ev[i] = pow(real(cev[i]), exp);  // power
        for(int j = 0; j<3; j++) {
            eV(i,j) = real(ceV(i,j));
            M(i,j) = 0;
        }
    }

    for(int r = 0; r < 3; r++) {
        for(int i = 0; i<3; i++) {
            for(int j = 0; j<3; j++) {
                M(i,j) += ev[r] * eV(r,i) * eV(r,j);
            }
        }
    }

}


// Run anisotropic remeshing
mesh3 ThNew = Th;
for(int i = 0; i<2; i++){

    int nv = ThNew.nv;
    real[int] metric(6 * nv);

    
    // tensor_R1 <- c(0.970, 0.0, 1.751, 0.0, 0.0, 0.842)
    // tensor_R2 <- c(1.556, 0.338, 1.165, 0.0, 0.0, 0.842)

    // Build custom anisotropic metric tensor at each vertex
    for (int i = 0; i < nv; i++) {

        real [int, int] M(3,3);

        if(ThNew(i).x < 0.5) {
            M(0,0) = 9.0;    // M11
            M(0,1) = 0.000;    // M12
            M(1,1) = 1.0;    // M22
            M(0,2) = 0.000;    // M13
            M(1,2) = 0.000;    // M23
            M(2,2) = 1.;    // M33
        }
        else {
            M(0,0) = 1.;    // M11
            M(0,1) = 0.000;    // M12
            M(1,1) = 9.;    // M22
            M(0,2) = 0.000;    // M13
            M(1,2) = 0.000;    // M23
            M(2,2) = 1.;    // M33
        }

        M(1,0) = M(0,1);
        M(2,0) = M(0,2);
        M(2,1) = M(1,2);

        
        POWER(M, 2);
        M = 10^3 * M;

        // ð‘š11,ð‘š21,ð‘š22,ð‘š31,ð‘š32,ð‘š33
        metric[6*i + 0] = M(0,0);  // M11
        metric[6*i + 1] = M(0,1);  // M12
        metric[6*i + 2] = M(1,1);  // M22
        metric[6*i + 3] = M(0,2);  // M13
        metric[6*i + 4] = M(1,2);  // M23
        metric[6*i + 5] = M(2,2);  // M33
    
    }


    ThNew = mmg3d(ThNew, metric=metric);
}

// Visualize
medit("aniso-mesh", ThNew);
savevtk("cube.vtk", ThNew);


