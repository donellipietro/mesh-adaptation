include "utils.edp"

// Options ----
verbosity = 0;
bool store = false;    // whether to store final computed mesh
bool plots = false;    // whether to display intermediate plots
real hmax = 1;
real hmin = 1e-3;
int nbvx = 1e6;
real TOL = 0.3;
int maxiter = 200;     // maximum number of iterations
real trf = 0.9;        // tolerance reduction factor
real ratiomax = 5;

// ------------------------------------------- anisotropic tensor field -- load from file
// build Delaunay mesh of convex hull
mesh Th = triangulate("data/nodes.txt");
if (plots) plot(Th, wait = true, cmm = "Starting point");

// Functional spaces
fespace VhP0(Th, P0);
fespace VhP1(Th, P1); // piecewise linear elements
int n = VhP1.ndof;

// load alpha factor
VhP1 alpha;
{
    ifstream file("data/alpha.txt");
    for(int i = 0; i < n; i++){
        file >> alpha[][i];
    }
}
// load tensor field [d11, d12, d22] evaluated at data/tensor/nodes.txt
VhP1 d11, d12, d22;
{
    ifstream file("data/D.txt");
    for(int i = 0; i < n; i++){
        file >> d11[][i] >> d12[][i] >> d22[][i];
    }
}
// tensor field components (scaling to amplify anisotropy in high alpha regions)
d11 = d11 * (4 * (alpha - 1) + 1);
d12 = d12 * (4 * (alpha - 1) + 1);
d22 = d22 * (4 * (alpha - 1) + 1);
// load tensor field logarithm
VhP1 logd11, logd12, logd22;
{
    ifstream file("data/logD.txt");
    for(int i = 0; i < n; i++){
        file >> logd11[][i] >> logd12[][i] >> logd22[][i];
    }
}

// discretized diffusion tensor components
VhP1 logd11h, logd12h, logd22h; // discrete gradient

// errors
varf vg11K(unused, chiK) = int2d(Th)(chiK*(
    square(dx(logd11h)) + 2 * square(dx(logd12h)) + square(dx(logd22h))
));
varf vg12K(unused, chiK) = int2d(Th)(chiK*(
    dx(logd11h) * dy(logd11h) + 2 * dx(logd12h) * dy(logd12h) + dx(logd22h) * dy(logd22h)
));
varf vg22K(unused, chiK) = int2d(Th)(chiK*(
    square(dy(logd11h)) + 2 * square(dy(logd12h)) + square(dy(logd22h))
));

// integral of L^2 norm of solution gradient
varf vsqetaK(unused, chiK) = 
    int2d(Th)(
        chiK*(
            square(dx(logd11h)) + 2*square(dx(logd12h)) + square(dx(logd22h)) +
            square(dy(logd11h)) + 2*square(dy(logd12h)) + square(dy(logd22h))
        )
    );

// start adaptation loop
real eta = 1e9;         // current global anisotropic error estimator
real TOL2 = TOL;        // Adaptive internal tolerance
real etamin = 1e9;      // Smallest eta observed
int stagnation = 0;     // Counter for consecutive improvements below TOL
int niter = 0;          // Iteration counter
int cnt = 0;            

// stop if solution doesn't improve error or maximum number of iteration reached
while(niter < maxiter && stagnation < 10) {
    int n = Th.nt;
    VhP0 Ak = area;
    real Aref = Ak[].sum;
    
    // update projected solutions
    logd11h = logd11;
    logd12h = logd12;
    logd22h = logd22;

    // compute per-element isotropic error estimator \eta_K = \int_K \| \nabla u_h |_K \|_2^2
    VhP0 etaK;
    etaK[] = vsqetaK(0, VhP0);
    etaK = sqrt(etaK);
    if(plots) { plot(etaK, cmm = "sqetaK " + niter,  wait=true, fill=true, value=true); }
    // update anisotropic error estimator \| \eta_K \|_{\infty}
    eta = etaK[].max;

    // adaptive stopping criterion
    if(eta < TOL){
        // eta below target tolerance
        if(eta < etamin){ // eta still decreasing
            etamin = eta;
            stagnation = 0; // reset stagnation counter
        } else {
            stagnation++;
        }
    } else {
        cnt++;
        if (cnt >= 5) {
            TOL2 = TOL2 * trf;
            cnt = 0;
        }
    }

    // output diagnostics
    cout << "iteration:    " << niter << endl;
    cout << "mesh size:    " << n << endl;
    cout << "eta:          " << eta << endl;
    cout << "stagnation:   " << stagnation << endl;
    cout << endl;

    // Compute gradient
    VhP0 G11K, G12K, G22K;
    G11K[] = vg11K(0, VhP0);
    G12K[] = vg12K(0, VhP0);
    G22K[] = vg22K(0, VhP0);
    if(plots) {
        plot(G11K, cmm = "G11K " + niter,  wait=true, fill=true, value=true);
        plot(G12K, cmm = "G12K " + niter,  wait=true, fill=true, value=true);
        plot(G22K, cmm = "G22K " + niter,  wait=true, fill=true, value=true);
    }

    VhP0 sqeta1K, sqeta2K, invsqlambda1K, invsqlambda2K;
    VhP0 r10K, r11K, r20K, r21K;

    real[int][int] MK(3);
    MK[0].resize(Th.nt);
    MK[1].resize(Th.nt);
    MK[2].resize(Th.nt);

    for(int k = 0; k < Th.nt; k++){
        // local anisotropy matrix of the gradient error on element k
        real[int, int] GK(2,2);
        GK(0,0) = G11K[][k];
        GK(0,1) = G12K[][k];
        GK(1,0) = G12K[][k];
        GK(1,1) = G22K[][k];

        // G_k spectral decomposition
        // G_k = R_k^\top * diag(ev[1], ev[2]) * R_k
        real[int] ev(2);
        real[int, int] eV(2, 2);
        EVD(GK, ev, eV, true);
        r10K[][k] = eV(0,1);
        r11K[][k] = eV(1,1);
        r20K[][k] = eV(0,0);
        r21K[][k] = eV(1,0);

        // build local metric tensor
        // M_k = R_k * diag(invsqlambda1K, invsqlambda2K) * R_k^\top

        sqeta1K[][k] = ev[0];
        sqeta2K[][k] = ev[1];
        // the more anistropic the local error, the more stretched the metric tensor becomes along R_k's eigenvectors
        invsqlambda1K[][k] = (2 * n * Aref * (sqeta2K[][k] / Ak[][k])) / (TOL2 * TOL2);
        invsqlambda2K[][k] = (2 * n * Aref * (sqeta1K[][k] / Ak[][k])) / (TOL2 * TOL2);

        // clamp eigenvalues
        if(invsqlambda1K[][k] > 1/(hmin * hmin)) { invsqlambda1K[][k] = 1 / (hmin * hmin); }
        if(invsqlambda2K[][k] > 1/(hmin * hmin)) { invsqlambda2K[][k] = 1 / (hmin * hmin); }
        if(invsqlambda1K[][k] < 1/(hmax * hmax)) { invsqlambda1K[][k] = 1 / (hmax * hmax); }
        if(invsqlambda2K[][k] < 1/(hmax * hmax)) { invsqlambda2K[][k] = 1 / (hmax * hmax); }

        // contraint maximum aspect ratio of element k
        real ratio = sqrt(ev[1] / ev[0]);
        if(ratio > ratiomax) {
            invsqlambda1K[][k] = invsqlambda2K[][k] / (ratiomax * ratiomax);
        }
        
        // metric assembly: R_k * diag(invsqlambda1K, invsqlambda2K) * R_k^\top
        MK[0][k] = invsqlambda1K[][k] * r10K[][k]^2 + invsqlambda2K[][k] * r11K[][k]^2;
        MK[1][k] = invsqlambda1K[][k] * r10K[][k] * r20K[][k] + invsqlambda2K[][k] * r11K[][k] * r21K[][k];
        MK[2][k] = invsqlambda1K[][k] * r20K[][k]^2 + invsqlambda2K[][k] * r21K[][k]^2;
    }

    // define metric tensor at mesh nodes by averaging of local tensors
    VhP1 m11N, m12N, m22N;
    real[int][int] MN(3);
    MN[0].resize(VhP1.ndof);
    MN[1].resize(VhP1.ndof);
    MN[2].resize(VhP1.ndof);
    tensorAveragingNodes(Th, MK, MN);
    m11N[] = MN[0];
    m12N[] = MN[1];
    m22N[] = MN[2];
    if(plots) { plot(m11N, wait = true, fill = true, value = true, cmm = "m11"); }
    if(plots) { plot(m12N, wait = true, fill = true, value = true, cmm = "m12"); }
    if(plots) { plot(m22N, wait = true, fill = true, value = true, cmm = "m22"); }

    // BAMG adaptation
    Th = adaptmesh(Th, metric = [m11N[], m12N[], m22N[]], hmin = hmin);
    if (plots) { plot(Th, wait = true); }
    niter++;
}

// final diagnostic
plot(Th, cmm = "Adapted mesh", fill = false, wait = true);
cout << "Number of triangles: " << Th.nt << endl;
cout << "Number of nodes: " << Th.nv << endl;

// save computed mesh
if (store) { savemesh(Th, "recovery_2.mesh"); }