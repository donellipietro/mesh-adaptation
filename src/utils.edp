load "lapack"

// compute the eigen-value decomposition of a 2x2 matrix, using the dgeev lapack routine
//
// M: input real matrix
// ev: output real vector of eigenvalues
// eV: output real matrix of eigenvectors
// POS: flag to enforce positive eigenvalues
func bool EVD(real[int, int] &M, real[int] &ev, real[int, int] &eV, bool POS) {
    // compute complex eigenvalue decomposition
    complex[int] cev(2);
    complex[int, int] ceV(2, 2);
    dgeev(M, cev, ceV);
    // extract only the real part
    // eigenvalues
    ev[0] = real(cev[0]);
    ev[1] = real(cev[1]);
    // eigenvectors
    eV(0,0) = real(ceV(0,0));
    eV(1,0) = real(ceV(1,0));
    eV(0,1) = real(ceV(0,1));
    eV(1,1) = real(ceV(1,1));
    // sort by eigenvalue magnitude
    if(ev[0] < ev[1]){
        ev[0] = real(cev[1]);
        ev[1] = real(cev[0]);
        eV(0,0) =  real(ceV(0, 1));
        eV(1,0) =  real(ceV(1, 1));
        eV(0,1) = -real(ceV(0, 0));
        eV(1,1) = -real(ceV(1, 0));
    }
    
    // ensure numerical positive definiteness of result by clamping negative eigenvalues to positive zero
    if(POS && ev[0] <= 0) { ev[0] = 1e-18; }
    if(POS && ev[1] <= 0) { ev[1] = 1e-18; }
    return true;
}

// given a 2x2 tensor fields [d11, d12, d22], computes its eigenvector matrix [r10, r11, r20, r21] and scalar factors
// alpha = \sqrt{\lambda_0 * \lambda_1}, gamma = \frac{\lambda_0}{alpha}
//
// [d11, d12, d22]: input SPD matrix
// ev0: output first  eigenvalue
// ev1: output second eigenvalue
// [r10, r11, r20, r21]: output eigenvector matrix
func bool decomposeTensorField(
   real[int] &d11, real[int] &d12, real[int] &d22,
   real[int] &ev0, real[int] &ev1,
   real[int] &r10, real[int] &r11, real[int] &r20, real[int] &r21) {
   int size = d11.n;
   for(int i = 0; i < size; i++) {
        // extract tensor field
        real[int, int] Di(2,2);
        Di(0,0) = d11[i];
        Di(0,1) = d12[i];
        Di(1,0) = d12[i];
        Di(1,1) = d22[i];
        // compute eigen decomposition
        real[int] eigval(2);
        real[int, int] eigvec(2, 2);
        EVD(Di, eigval, eigvec, true);
        // eigenvectors
        r10[i] = eigvec(0,0);
        r11[i] = eigvec(1,0);
        r20[i] = eigvec(0,1);
        r21[i] = eigvec(1,1);
	// eigenvalues
        ev0[i] = eigval[0];
        ev1[i] = eigval[1];
    }
    return true;
}

// compute an area-weighted nodal average of an elementwise (P0) scalar field.
//
// Th: input mesh
// vh0: elementwise scalar field (P0 values, one per triangle)
// vmin: minimum allowed value for the averaged nodal field
// vmax: maximum allowed value for the averaged nodal field
func real[int] averagingNodes(mesh &Th, real[int] &vh0, real vmin, real vmax) {
    fespace VhP1(Th, P1);
    fespace VhP0(Th, P0);
    VhP1 vh1;
    VhP0 AK = area;

    real[int] areaSumNode(VhP1.ndof), vhSumNode(VhP1.ndof);
    areaSumNode = 0; vhSumNode = 0;
    
    for(int k = 0; k < Th.nt; ++k) {
        real aK = AK[][k];
        for(int i=0; i<3; i++) {
            int index = Th[k][i];
            areaSumNode[index] += aK;
            vhSumNode[index] += aK * vh0[k];
        }
    }
    
    for(int n = 0; n < Th.nv; ++n) {
        if(areaSumNode[n] > 1e-30){
            vh1[][n] = vhSumNode[n] / areaSumNode[n];
        } else{
            vh1[][n] = vmin;
        }

        vh1[][n] = min(vmax, max(vmin, vh1[][n]));
    }
    return(vh1[]);
}




// Precompute vertex-to-element connectivity once
func int[int,int] buildVertexToElem(mesh &Th) {
    // First pass: count how many elements per vertex
    int[int] count(Th.nv);
    for (int k = 0; k < Th.nt; k++) {
        for (int i = 0; i < 3; i++) {
            count[Th[k][i]]++;
	}
    }

    // build a matrix representation of patch connectivity. As not all vertices have the same patch cardinality, let
    // first entry of the matrix be the number of elements in the patch
    int maxNeigh = count.max; 
    int[int,int] vertexToElem(Th.nv, maxNeigh + 1);
    for (int v = 0; v < Th.nv; v++) {
        vertexToElem(v,0) = 0;
    }

    for (int k = 0; k < Th.nt; k++) {
        for (int i = 0; i < 3; i++) {
            int v = Th[k][i];
	    // increase patch counter for this vertex
	    vertexToElem(v, 0)++;
	    // store element k in patch of node v
            vertexToElem(v, vertexToElem(v, 0)) = k;
        }
    }
    return vertexToElem;
}


func int[int] getPatch(mesh &Th, int k, int[int,int] &vertexToElem) {
    // Collect all unique triangles that share a vertex with triangle k
    int[int] mark(Th.nt); // boolean-like marker
    for (int i = 0; i < 3; i++) {
        int vi = Th[k][i];
        for (int j = 0; j < vertexToElem(vi,0); j++) {
            int elem = vertexToElem(vi, j+1);
            mark[elem] = true;
        }
    }

    // Build patch
    int[int] patch(0);
    for (int j = 0; j < Th.nt; j++) {
        if (mark[j]) {
            patch.resize(patch.n + 1);
            patch[patch.n - 1] = j;
        }
    }
    return patch;
}








// computes the matrix logarithm

func bool logTensorFiled(real[int][int] &Dh0, real[int][int] &logDh0) {
    for(int i = 0; i < Dh0[0].n; i++) {
        real[int, int] Di(2,2);
        Di(0,0) = Dh0[0][i];
        Di(0,1) = Dh0[1][i];
        Di(1,0) = Dh0[1][i];
        Di(1,1) = Dh0[2][i];
        real[int] ev(2);
        real[int, int] eV(2, 2);
        EVD(Di, ev, eV, true);
        real[int] r1i = [eV(0,0), eV(1,0)];
        real[int] r2i = [eV(0,1), eV(1,1)];
        logDh0[0][i] = log(ev[0]) * r1i[0]^2 + log(ev[1]) * r2i[0]^2;
        logDh0[1][i] = log(ev[0]) * r1i[0]*r1i[1] + log(ev[1]) * r2i[0]*r2i[1];
        logDh0[2][i] = log(ev[0]) * r1i[1]^2 + log(ev[1]) * r2i[1]^2;
    }
    // cout << logDh0 << endl;
    return(true);
}

func bool expTensorFiled(real[int][int] &Dh0, real[int][int] &expDh0) {
    for(int i = 0; i < Dh0[0].n; i++) {
        real[int, int] Di(2,2);
        Di(0,0) = Dh0[0][i];
        Di(0,1) = Dh0[1][i];
        Di(1,0) = Dh0[1][i];
        Di(1,1) = Dh0[2][i];
        real[int] ev(2);
        real[int, int] eV(2, 2);
        EVD(Di, ev, eV, false);
        real[int] r1i = [eV(0,0), eV(1,0)];
        real[int] r2i = [eV(0,1), eV(1,1)];
        expDh0[0][i] = exp(ev[0]) * r1i[0]^2 + exp(ev[1]) * r2i[0]^2;
        expDh0[1][i] = exp(ev[0]) * r1i[0]*r1i[1] + exp(ev[1]) * r2i[0]*r2i[1];
        expDh0[2][i] = exp(ev[0]) * r1i[1]^2 + exp(ev[1]) * r2i[1]^2;
    }
    return(true);
}

func bool tensorAveragingNodes(mesh &Th, real[int][int] &Dh0, real[int][int] &Dh0av) {

    real[int][int] logDh0(3);
    logDh0[0].resize(Th.nt);
    logDh0[1].resize(Th.nt);
    logDh0[2].resize(Th.nt);
    logTensorFiled(Dh0, logDh0);

    int ndof = Dh0av[0].n;
    real[int][int] logDhav(3);
    logDhav[0].resize(ndof);
    logDhav[0] = averagingNodes(Th, logDh0[0], -1e9, 1e9);
    logDhav[1].resize(ndof);
    logDhav[1] = averagingNodes(Th, logDh0[1], -1e9, 1e9);
    logDhav[2].resize(ndof);
    logDhav[2] = averagingNodes(Th, logDh0[2], -1e9, 1e9);

    expTensorFiled(logDhav, Dh0av);
    return(true);
    
}





func real computeEccentricity(mesh &Th, int k) {

    real[int][int] Triangle(3);
    Triangle[0].resize(2);
    Triangle[1].resize(2);
    Triangle[2].resize(2);

    for(int i = 0; i<3; ++i){
        Triangle[i][0] = Th[k][i].x;
        Triangle[i][1] = Th[k][i].y;
    }

    real[int] A = Triangle[0];
    real[int] B = Triangle[1];
    real[int] C = Triangle[2];

    // Compute centroid G
    real[int] G(2);
    G[0] = (A[0] + B[0] + C[0])/3;
    G[1] = (A[1] + B[1] + C[1])/3;

    // Centered coordinates
    real[int] An(2), Bn(2), Cn(2);
    An[0] = A[0] - G[0]; An[1] = A[1] - G[1];
    Bn[0] = B[0] - G[0]; Bn[1] = B[1] - G[1];
    Cn[0] = C[0] - G[0]; Cn[1] = C[1] - G[1];

    // Compute covariance matrix (up to scaling)
    real Sxx = (An[0]^2 + Bn[0]^2 + Cn[0]^2)/3;
    real Syy = (An[1]^2 + Bn[1]^2 + Cn[1]^2)/3;
    real Sxy = (An[0]*An[1] + Bn[0]*Bn[1] + Cn[0]*Cn[1])/3;

    // Compute eigenvalues of the covariance matrix
    real trace = Sxx + Syy;
    real det = Sxx*Syy - Sxy^2;
    real delta = sqrt(trace^2/4 - det);
    real lambda1 = trace/2 + delta;
    real lambda2 = trace/2 - delta;

    // Compute eccentricity: e = sqrt(1 - (lambda2/lambda1))
    real ecc = sqrt(1.0 - lambda2/lambda1);

    // Compute r = lambda1/lambda2
    real ratio = lambda1/lambda2;

    // cout << "Eccentricity of the Steiner ellipse: " << ecc << endl;
    // cout << "Ratio of the Steiner ellipse: " << ratio << endl;

    return ratio;

}
