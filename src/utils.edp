load "lapack"

// compute the eigen-value decomposition of a 2x2 matrix, using the dgeev lapack routine
//
// M: input real matrix
// ev: output real vector of eigenvalues
// eV: output real matrix of eigenvectors
// POS: flag to enforce positive eigenvalues
func bool EVD(real[int, int] &M, real[int] &ev, real[int, int] &eV, bool POS) {
    // compute complex eigenvalue decomposition
    complex[int] cev(2);
    complex[int, int] ceV(2, 2);
    dgeev(M, cev, ceV);
    // extract only the real part
    // eigenvalues
    ev[0] = real(cev[0]);
    ev[1] = real(cev[1]);
    // eigenvectors
    eV(0,0) = real(ceV(0,0));
    eV(1,0) = real(ceV(1,0));
    eV(0,1) = real(ceV(0,1));
    eV(1,1) = real(ceV(1,1));
    // sort by eigenvalue magnitude
    if(ev[0] < ev[1]){
        ev[0] = real(cev[1]);
        ev[1] = real(cev[0]);
        eV(0,0) =  real(ceV(0, 1));
        eV(1,0) =  real(ceV(1, 1));
        eV(0,1) = -real(ceV(0, 0));
        eV(1,1) = -real(ceV(1, 0));
    }
    
    // ensure numerical positive definiteness of result by clamping negative eigenvalues to positive zero
    if(POS && ev[0] <= 0) { ev[0] = 1e-18; }
    if(POS && ev[1] <= 0) { ev[1] = 1e-18; }
    return true;
}

// given a 2x2 tensor fields [d11, d12, d22], computes its eigenvector matrix [r10, r11, r20, r21] and scalar factors
// alpha = \sqrt{\lambda_0 * \lambda_1}, gamma = \frac{\lambda_0}{alpha}
//
// [d11, d12, d22]: input SPD matrix
// ev0: output first  eigenvalue
// ev1: output second eigenvalue
// [r10, r11, r20, r21]: output eigenvector matrix
func bool decomposeTensorField(
   real[int] &d11, real[int] &d12, real[int] &d22,
   real[int] &ev0, real[int] &ev1,
   real[int] &r10, real[int] &r11, real[int] &r20, real[int] &r21) {
   int size = d11.n;
   for(int i = 0; i < size; i++) {
        // extract tensor field
        real[int, int] Di(2,2);
        Di(0,0) = d11[i];
        Di(0,1) = d12[i];
        Di(1,0) = d12[i];
        Di(1,1) = d22[i];
        // compute eigen decomposition
        real[int] eigval(2);
        real[int, int] eigvec(2, 2);
        EVD(Di, eigval, eigvec, true);
        // eigenvectors
        r10[i] = eigvec(0,0);
        r11[i] = eigvec(1,0);
        r20[i] = eigvec(0,1);
        r21[i] = eigvec(1,1);
        // eigenvalues
        ev0[i] = eigval[0];
        ev1[i] = eigval[1];
    }
    return true;
}

// compute an area-weighted nodal average of an elementwise (P0) scalar field.
//
// Th: input mesh
// vh0: elementwise scalar field (P0 values, one per triangle)
// vmin: minimum allowed value for the averaged nodal field
// vmax: maximum allowed value for the averaged nodal field
func real[int] averagingNodes(mesh &Th, real[int] &vh0, real vmin, real vmax) {
    fespace VhP1(Th, P1);
    fespace VhP0(Th, P0);
    VhP1 vh1;
    VhP0 AK = area;

    real[int] areaSumNode(VhP1.ndof), vhSumNode(VhP1.ndof);
    areaSumNode = 0; vhSumNode = 0;
    
    for(int k = 0; k < Th.nt; ++k) {
        real aK = AK[][k];
        for(int i=0; i<3; i++) {
            int index = Th[k][i];
            areaSumNode[index] += aK;
            vhSumNode[index] += aK * vh0[k];
        }
    }
    
    for(int n = 0; n < Th.nv; ++n) {
        if(areaSumNode[n] > 1e-30){
            vh1[][n] = vhSumNode[n] / areaSumNode[n];
        } else{
            vh1[][n] = vmin;
        }

        vh1[][n] = min(vmax, max(vmin, vh1[][n]));
    }
    return(vh1[]);
}

// computes the matrix logarithm
//
// Dh0:    input SPD matrix
// logDh0: output matrix logarithm
func bool logTensorFiled(real[int][int] &Dh0, real[int][int] &logDh0) {
    for(int i = 0; i < Dh0[0].n; i++) {
        // spectral decomposition of i-th tensor
        real[int, int] Di(2,2);
        Di(0,0) = Dh0[0][i];
        Di(0,1) = Dh0[1][i];
        Di(1,0) = Dh0[1][i];
        Di(1,1) = Dh0[2][i];
        real[int] ev(2);
        real[int, int] eV(2, 2);
        EVD(Di, ev, eV, true);
        real[int] r1i = [eV(0,0), eV(1,0)];
        real[int] r2i = [eV(0,1), eV(1,1)];

        // compute matrix logarithm by taking the logarithm of its eigenvalues
        logDh0[0][i] = log(ev[0]) * r1i[0]^2 + log(ev[1]) * r2i[0]^2;
        logDh0[1][i] = log(ev[0]) * r1i[0]*r1i[1] + log(ev[1]) * r2i[0]*r2i[1];
        logDh0[2][i] = log(ev[0]) * r1i[1]^2 + log(ev[1]) * r2i[1]^2;
    }
    return true;
}

// computes the matrix exponential
//
// Dh0:    input SPD matrix
// logDh0: output matrix exponential
func bool expTensorFiled(real[int][int] &Dh0, real[int][int] &expDh0) {
    for(int i = 0; i < Dh0[0].n; i++) {
        // spectral decomposition of i-th tensor
        real[int, int] Di(2,2);
        Di(0,0) = Dh0[0][i];
        Di(0,1) = Dh0[1][i];
        Di(1,0) = Dh0[1][i];
        Di(1,1) = Dh0[2][i];
        real[int] ev(2);
        real[int, int] eV(2, 2);
        EVD(Di, ev, eV, false);
        real[int] r1i = [eV(0,0), eV(1,0)];
        real[int] r2i = [eV(0,1), eV(1,1)];

        // compute matrix exponential by taking the exponential of its eigenvalues
        expDh0[0][i] = exp(ev[0]) * r1i[0]^2 + exp(ev[1]) * r2i[0]^2;
        expDh0[1][i] = exp(ev[0]) * r1i[0]*r1i[1] + exp(ev[1]) * r2i[0]*r2i[1];
        expDh0[2][i] = exp(ev[0]) * r1i[1]^2 + exp(ev[1]) * r2i[1]^2;
    }
    return(true);
}

// perform nodal averaging of a 2D tensor field defined on mesh elements
//
// Th:    input mesh
// Dh0:   input tensor field evaluted at mesh nodes
// Dh0av: output averaged tensor field
func bool tensorAveragingNodes(mesh &Th, real[int][int] &Dh0, real[int][int] &Dh0av) {
    // move to logarithmic domain (euclidean structure) 
    real[int][int] logDh0(3);
    logDh0[0].resize(Th.nt);
    logDh0[1].resize(Th.nt);
    logDh0[2].resize(Th.nt);
    logTensorFiled(Dh0, logDh0);

    // perform average in the logarithmic domain, i.e. compute nodal average of scalar components
    int ndof = Dh0av[0].n;
    real[int][int] logDhav(3);
    logDhav[0].resize(ndof);
    logDhav[0] = averagingNodes(Th, logDh0[0], -1e9, 1e9);
    logDhav[1].resize(ndof);
    logDhav[1] = averagingNodes(Th, logDh0[1], -1e9, 1e9);
    logDhav[2].resize(ndof);
    logDhav[2] = averagingNodes(Th, logDh0[2], -1e9, 1e9);

    // back to SPD domain by exponentiation
    expTensorFiled(logDhav, Dh0av);
    return true;
}

// utilities to compute element patch (set of all elements sharing any vertex with a given element)

func int[int,int] buildVertexToElem(mesh &Th) {
    // First pass: count how many elements per vertex
    int[int] count(Th.nv);
    for (int k = 0; k < Th.nt; k++) {
        for (int i = 0; i < 3; i++) {
            count[Th[k][i]]++;
        }
    }

    // build a matrix representation of patch connectivity. As not all vertices have the same patch cardinality, let
    // first entry of the matrix be the number of elements in the patch
    int maxNeigh = count.max; 
    int[int,int] vertexToElem(Th.nv, maxNeigh + 1);
    for (int v = 0; v < Th.nv; v++) {
        vertexToElem(v,0) = 0;
    }

    for (int k = 0; k < Th.nt; k++) {
        for (int i = 0; i < 3; i++) {
            int v = Th[k][i];
            // increase patch counter for this vertex
            vertexToElem(v, 0)++;
            // store element k in patch of node v
            vertexToElem(v, vertexToElem(v, 0)) = k;
        }
    }
    return vertexToElem;
}
func int[int] getPatch(mesh &Th, int k, int[int,int] &vertexToElem) {
    // collect all unique triangles that share a vertex with triangle k
    int[int] mark(Th.nt); // boolean-like marker
    for (int i = 0; i < 3; i++) {
        int vi = Th[k][i];
        for (int j = 0; j < vertexToElem(vi,0); j++) {
            int elem = vertexToElem(vi, j+1);
            mark[elem] = true;
        }
    }

    // build patch
    int[int] patch(0);
    for (int j = 0; j < Th.nt; j++) {
        if (mark[j]) {
            patch.resize(patch.n + 1);
            patch[patch.n - 1] = j;
        }
    }
    return patch;
}